# ESP32 to ESP32-S3 Pin Mapping Button Test
esphome:
  name: esp32-s3-pin-mapping
  friendly_name: ESP32-S3 Pin Mapping Test
  project:
    name: "test.esp32-s3-pin-mapping"
    version: "1.0.0"

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino
    version: recommended

logger:
  level: DEBUG

api:

ota:
  - platform: esphome

wifi:
  ap:
    ssid: "ESP32-S3-Pin-Mapping"
    password: "shrooly123"

i2c:
  sda: GPIO36
  scl: GPIO35
  scan: true
  id: bus_a
  frequency: 100khz

spi:
  clk_pin: GPIO7
  mosi_pin: GPIO6

font:
  - file: fonts/arial.ttf
    id: font_medium
    size: 10
  - file: fonts/arial.ttf
    id: font_small
    size: 8

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: GPIO8
    dc_pin: GPIO48
    busy_pin: GPIO38
    reset_pin: GPIO21
    rotation: 90°
    model: 2.90inv2-r2
    update_interval: never
    lambda: |-
      it.print(5, 5, id(font_medium), "ESP32-S3 PIN MAPPING TEST");
      it.print(5, 20, id(font_small), "Testing ESP32->S3 equivalent pins");
      
      it.printf(5, 35, id(font_small), "ESP32 GPIO0 -> S3 safe pins");
      it.printf(5, 45, id(font_small), "ESP32 GPIO35 -> S3 safe pins");
      it.printf(5, 55, id(font_small), "ESP32 GPIO32 -> S3 safe pins");
      it.printf(5, 65, id(font_small), "ESP32 GPIO33 -> S3 safe pins");
      
      it.printf(5, 80, id(font_small), "Button presses: %d", id(button_count));
      
      if (id(mapping_detected)) {
        it.print(5, 95, id(font_small), "BUTTON MAPPING FOUND!");
        it.print(5, 110, id(font_small), "Check logs for pin details");
      } else {
        it.print(5, 110, id(font_small), "Press buttons to find mapping");
      }

globals:
  - id: button_count
    type: int
    restore_value: false
    initial_value: '0'
  - id: mapping_detected
    type: bool
    restore_value: false
    initial_value: 'false'

binary_sensor:
  # Original Enhanced OpenShrooly used these pins on ESP32:
  # GPIO0 (Left), GPIO35 (Select), GPIO32 (Right), GPIO33 (Menu)
  
  # ESP32-S3 SAFE alternatives for ESP32 GPIO0 (boot strapping pin)
  - platform: gpio
    pin:
      number: GPIO9    # Safe alternative to GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt for GPIO0 (Pin9)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ LEFT BUTTON found on GPIO9 (was GPIO0 on ESP32)");
      - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO10   # Another safe alternative to GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt2 for GPIO0 (Pin10)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ LEFT BUTTON found on GPIO10 (was GPIO0 on ESP32)");
      - component.update: my_display

  # ESP32-S3 alternatives for ESP32 GPIO35 (input-only pin)
  - platform: gpio
    pin:
      number: GPIO11   # Safe input/output pin
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt for GPIO35 (Pin11)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ SELECT BUTTON found on GPIO11 (was GPIO35 on ESP32)");
      - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO12   # Another safe alternative
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt2 for GPIO35 (Pin12)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ SELECT BUTTON found on GPIO12 (was GPIO35 on ESP32)");
      - component.update: my_display

  # ESP32-S3 alternatives for ESP32 GPIO32 (SPI conflict)
  - platform: gpio
    pin:
      number: GPIO13   # Safe alternative
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt for GPIO32 (Pin13)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ RIGHT BUTTON found on GPIO13 (was GPIO32 on ESP32)");
      - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO14   # Another safe alternative
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt2 for GPIO32 (Pin14)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ RIGHT BUTTON found on GPIO14 (was GPIO32 on ESP32)");
      - component.update: my_display

  # ESP32-S3 alternatives for ESP32 GPIO33
  - platform: gpio
    pin:
      number: GPIO15   # Safe alternative
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt for GPIO33 (Pin15)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ MENU BUTTON found on GPIO15 (was GPIO33 on ESP32)");
      - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO16   # Another safe alternative
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 Alt2 for GPIO33 (Pin16)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ MENU BUTTON found on GPIO16 (was GPIO33 on ESP32)");
      - component.update: my_display

  # Test some high-numbered pins that might be mapped
  - platform: gpio
    pin:
      number: GPIO37   # High number pins
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 GPIO37 Test"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ BUTTON found on GPIO37");
      - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO39   # Different high number test (avoid GPIO38 display conflict)
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 GPIO39 Test"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ BUTTON found on GPIO39");
      - component.update: my_display

  # Test GPIO pins that might be hardware-routed differently
  - platform: gpio
    pin:
      number: GPIO17   # Test more pins
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 GPIO17 Test"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ BUTTON found on GPIO17");
      - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO18   # Test more pins
      mode: INPUT_PULLUP
      inverted: true
    name: "ESP32-S3 GPIO18 Test"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - lambda: |-
          id(button_count)++;
          id(mapping_detected) = true;
          ESP_LOGE("MAPPING", "✅ BUTTON found on GPIO18");
      - component.update: my_display

  # Known working GPIO5 for reference
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "Reference_GPIO5 (Known Working)"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log: "🟢 REFERENCE: GPIO5 confirmed working"

interval:
  - interval: 3s
    then:
      - logger.log: "🔍 ESP32-S3 Pin Mapping Test - Finding ESP32->S3 button remapping"
      - component.update: my_display