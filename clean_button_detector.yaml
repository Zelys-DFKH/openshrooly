# Clean Button Detector - Eliminates false positives, tests alternative methods
esphome:
  name: clean-button-detector
  friendly_name: Clean Button Detector
  project:
    name: "detector.clean-buttons"
    version: "1.0.0"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino
    version: recommended

logger:
  level: DEBUG

wifi:
  ap:
    ssid: "Clean-Button-Detector"
    password: "shrooly123"

# Add I2C to test for I2C button expanders
i2c:
  sda: GPIO36
  scl: GPIO35
  scan: true
  id: bus_a
  frequency: 100khz

spi:
  clk_pin: GPIO7
  mosi_pin: GPIO6

font:
  - file: fonts/arial.ttf
    id: font_medium
    size: 10

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: GPIO8
    dc_pin: GPIO48
    busy_pin: GPIO38
    reset_pin: GPIO21
    rotation: 90¬∞
    model: 2.90inv2-r2
    update_interval: never
    lambda: |-
      it.print(5, 5, id(font_medium), "CLEAN BUTTON DETECTOR");
      it.printf(5, 20, id(font_medium), "Noise detections: %d", id(noise_count));
      it.printf(5, 35, id(font_medium), "Real button presses: %d", id(real_count));
      it.printf(5, 50, id(font_medium), "Last confirmed: GPIO%d", id(last_confirmed));
      
      if (id(real_count) > 0) {
        int y = 65;
        for (int i = 0; i < 4 && id(confirmed_gpios)[i] != -1; i++) {
          it.printf(5, y, id(font_medium), "Button %d: GPIO%d", i+1, id(confirmed_gpios)[i]);
          y += 12;
        }
      } else {
        it.print(5, 65, id(font_medium), "No buttons found yet");
        it.print(5, 80, id(font_medium), "Try holding buttons 2+ sec");
        it.print(5, 95, id(font_medium), "Checking I2C & analog...");
      }

globals:
  - id: noise_count
    type: int
    restore_value: false
    initial_value: '0'
  - id: real_count
    type: int
    restore_value: false
    initial_value: '0'
  - id: last_confirmed
    type: int
    restore_value: false
    initial_value: '-1'
  - id: confirmed_gpios
    type: int[4]
    restore_value: false

script:
  - id: confirm_real_button
    parameters:
      gpio_num: int
    then:
      - lambda: |-
          // Only accept if not already detected and seems real
          bool already_found = false;
          for (int i = 0; i < 4; i++) {
            if (id(confirmed_gpios)[i] == gpio_num) {
              already_found = true;
              break;
            }
          }
          
          if (!already_found && id(real_count) < 4) {
            id(confirmed_gpios)[id(real_count)] = gpio_num;
            id(real_count)++;
            id(last_confirmed) = gpio_num;
            ESP_LOGE("CLEAN", "‚úÖ CONFIRMED REAL BUTTON: GPIO%d", gpio_num);
          }
      - component.update: my_display

binary_sensor:
  # Test only the most stable GPIO pins with strict filtering
  # Require 2+ second press to eliminate noise
  
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO0"
    filters:
      - delayed_on: 2000ms  # Must hold 2 seconds
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 0
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - lambda: id(noise_count)++;
          - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO1
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO1"
    filters:
      - delayed_on: 2000ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 1
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - lambda: id(noise_count)++;
          - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO2
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO2"
    filters:
      - delayed_on: 2000ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 2
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - lambda: id(noise_count)++;
          - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO3"
    filters:
      - delayed_on: 2000ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 3
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - lambda: id(noise_count)++;
          - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO4"
    filters:
      - delayed_on: 2000ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 4
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - lambda: id(noise_count)++;
          - component.update: my_display

  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO5"
    filters:
      - delayed_on: 2000ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 5
    on_click:
      - min_length: 50ms
        max_length: 500ms
        then:
          - lambda: id(noise_count)++;
          - component.update: my_display

  # Test a few more likely pins with same strict filtering
  - platform: gpio
    pin:
      number: GPIO9
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO9"
    filters:
      - delayed_on: 2000ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 9

  - platform: gpio
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
      inverted: true
    name: "Clean_GPIO10"
    filters:
      - delayed_on: 2000ms
      - delayed_off: 100ms
    on_press:
      - script.execute:
          id: confirm_real_button
          gpio_num: 10

# Test alternative button connection methods
sensor:
  # Test for analog button ladder/matrix
  - platform: adc
    pin: GPIO1
    name: "Analog Button Test GPIO1"
    id: analog_btn1
    update_interval: 500ms
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 4
          send_every: 2

  - platform: adc
    pin: GPIO2
    name: "Analog Button Test GPIO2" 
    id: analog_btn2
    update_interval: 500ms
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 4
          send_every: 2

# Log I2C scan results to check for button expander chips
interval:
  - interval: 10s
    then:
      - logger.log: "üîç Scanning for I2C devices and analog levels"
      - if:
          condition:
            lambda: return id(real_count) == 0 && id(noise_count) > 5;
          then:
            - logger.log: "‚ö†Ô∏è Too much noise - buttons may be on I2C expander or analog"