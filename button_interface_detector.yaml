# Button Interface Detective - Find the REAL button interface
esphome:
  name: enhanced-openshrooly  
  friendly_name: Button Detective
  project:
    name: "enhanced.openshrooly"
    version: "2.2.0-detective"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino
    version: recommended

logger:
  level: DEBUG

api:

ota:
  - platform: esphome

wifi:
  ap:
    ssid: "Enhanced-OpenShrooly-Setup"
    password: "shrooly123"

captive_portal:
web_server:
  port: 80

# Working I2C bus
i2c:
  sda: GPIO36
  scl: GPIO35
  scan: true
  id: bus_a
  frequency: 100khz

spi:
  clk_pin: GPIO7
  mosi_pin: GPIO6

font:
  - file: fonts/arial.ttf
    id: font_medium
    size: 12

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: GPIO8
    dc_pin: GPIO48
    busy_pin: GPIO38
    reset_pin: GPIO21
    rotation: 90춿
    model: 2.90inv2-r2
    update_interval: 20s
    lambda: |-
      it.print(5, 5, id(font_medium), "BUTTON DETECTIVE");
      it.print(5, 25, id(font_medium), "Monitoring I2C + ADC");
      it.print(5, 45, id(font_medium), "Press buttons now!");
      it.print(5, 65, id(font_medium), "Check serial log");

# Touch sensor component (must be before binary_sensor)
esp32_touch:

# All binary sensors: GPIO reference + Touch detection
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "GPIO5 Reset (Reference)"
    id: gpio5_button
    on_press:
      - logger.log: 
          format: "游댮 GPIO5 RESET PRESSED - Reference working!"
          level: ERROR

  # Touch sensor monitoring (capacitive buttons)  
  - platform: esp32_touch
    name: "Touch GPIO1"
    pin: GPIO1
    threshold: 1000
    id: touch1
    on_press:
      - logger.log:
          format: "游릭 TOUCH GPIO1 - FOUND CAPACITIVE BUTTON!"
          level: ERROR

  - platform: esp32_touch  
    name: "Touch GPIO2"
    pin: GPIO2
    threshold: 1000
    id: touch2
    on_press:
      - logger.log:
          format: "游릭 TOUCH GPIO2 - FOUND CAPACITIVE BUTTON!"
          level: ERROR

  - platform: esp32_touch
    name: "Touch GPIO3" 
    pin: GPIO3
    threshold: 1000
    id: touch3
    on_press:
      - logger.log:
          format: "游릭 TOUCH GPIO3 - FOUND CAPACITIVE BUTTON!"
          level: ERROR

  - platform: esp32_touch
    name: "Touch GPIO4"
    pin: GPIO4  
    threshold: 1000
    id: touch4
    on_press:
      - logger.log:
          format: "游릭 TOUCH GPIO4 - FOUND CAPACITIVE BUTTON!"
          level: ERROR

# ADC monitoring for voltage divider buttons
sensor:
  - platform: sht4x
    i2c_id: bus_a
    temperature:
      name: "Temperature"
      id: temperature
    humidity:
      name: "Humidity"  
      id: humidity
    update_interval: 10s

  # Monitor ADC pins for button voltage changes
  - platform: adc
    pin: GPIO1
    name: "ADC1 Voltage"
    id: adc1
    update_interval: 0.1s
    accuracy_decimals: 3
    filters:
      - delta: 0.05
    on_value:
      - lambda: |-
          if (x > 0.1 && x < 3.2) {
            ESP_LOGE("adc", "游릭 ADC1 (GPIO1): %.3fV - POSSIBLE BUTTON!", x);
          }

  - platform: adc  
    pin: GPIO2
    name: "ADC2 Voltage"
    id: adc2
    update_interval: 0.1s
    accuracy_decimals: 3
    filters:
      - delta: 0.05
    on_value:
      - lambda: |-
          if (x > 0.1 && x < 3.2) {
            ESP_LOGE("adc", "游릭 ADC2 (GPIO2): %.3fV - POSSIBLE BUTTON!", x);
          }

  - platform: adc
    pin: GPIO3  
    name: "ADC3 Voltage"
    id: adc3
    update_interval: 0.1s
    accuracy_decimals: 3
    filters:
      - delta: 0.05
    on_value:
      - lambda: |-
          if (x > 0.1 && x < 3.2) {
            ESP_LOGE("adc", "游릭 ADC3 (GPIO3): %.3fV - POSSIBLE BUTTON!", x);
          }

  - platform: adc
    pin: GPIO4
    name: "ADC4 Voltage" 
    id: adc4
    update_interval: 0.1s
    accuracy_decimals: 3
    filters:
      - delta: 0.05
    on_value:
      - lambda: |-
          if (x > 0.1 && x < 3.2) {
            ESP_LOGE("adc", "游릭 ADC4 (GPIO4): %.3fV - POSSIBLE BUTTON!", x);
          }

# I2C button detection + comprehensive scanning
interval:
  - interval: 2s
    then:
      - logger.log: 
          format: "游댌 BUTTON DETECTIVE - Press buttons to find interface"
          level: ERROR
      # Comprehensive I2C GPIO expander scanning
      - lambda: |-
          ESP_LOGI("i2c", "=== I2C BUTTON SCAN START ===");
          
          // Common GPIO expander addresses
          uint8_t addresses[] = {0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
                                0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F};
          
          for (int i = 0; i < 16; i++) {
            uint8_t addr = addresses[i];
            
            // Try to read from potential GPIO expander
            uint8_t data;
            Wire.beginTransmission(addr);
            if (Wire.endTransmission() == 0) {
              ESP_LOGI("i2c", "Device found at 0x%02X", addr);
              
              // Try to read GPIO states
              Wire.requestFrom(addr, 1);
              if (Wire.available()) {
                data = Wire.read();
                ESP_LOGE("i2c", "游릭 0x%02X READ: 0x%02X", addr, data);
              }
            }
          }
          
          // Also scan for any NEW I2C devices
          ESP_LOGI("i2c", "=== FULL I2C BUS SCAN ===");
          for (uint8_t address = 1; address < 127; address++) {
            Wire.beginTransmission(address);
            uint8_t error = Wire.endTransmission();
            if (error == 0) {
              ESP_LOGI("i2c", "I2C device at 0x%02X", address);
              
              // Try reading 1 byte from each device
              Wire.requestFrom(address, 1);
              if (Wire.available()) {
                uint8_t value = Wire.read();
                ESP_LOGI("i2c", "0x%02X value: 0x%02X", address, value);
              }
            }
          }
          ESP_LOGI("i2c", "=== I2C SCAN COMPLETE ===");

