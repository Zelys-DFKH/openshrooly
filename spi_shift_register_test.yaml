# SPI Shift Register Button Test - 74HC165 Parallel-to-Serial Input
esphome:
  name: spi-shift-register-test
  friendly_name: SPI Shift Register Button Test
  project:
    name: "test.spi-shift-register"
    version: "1.0.0"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino
    version: recommended

logger:
  level: DEBUG

wifi:
  ap:
    ssid: "SPI-Shift-Register-Test"
    password: "shrooly123"

# Modified SPI configuration for shift register input
spi:
  clk_pin: GPIO7   # Clock (existing)
  mosi_pin: GPIO6  # Data out (existing, for display)
  miso_pin: GPIO9  # Data in for shift registers
  id: main_spi

i2c:
  sda: GPIO36
  scl: GPIO35
  scan: true
  id: bus_a
  frequency: 100khz

font:
  - file: fonts/arial.ttf
    id: font_medium
    size: 10
  - file: fonts/arial.ttf
    id: font_small
    size: 8

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: GPIO8
    dc_pin: GPIO48
    busy_pin: GPIO38
    reset_pin: GPIO21
    rotation: 90Â°
    model: 2.90inv2-r2
    update_interval: never
    lambda: |-
      it.print(5, 5, id(font_medium), "SPI SHIFT REGISTER TEST");
      it.print(5, 20, id(font_small), "Testing 74HC165 button input");
      
      // Show shift register readings
      it.printf(5, 35, id(font_small), "SR1 (0x10): 0x%02X", id(shift_reg_1_state));
      it.printf(5, 50, id(font_small), "SR2 (0x11): 0x%02X", id(shift_reg_2_state));
      it.printf(5, 65, id(font_small), "SR3 (0x12): 0x%02X", id(shift_reg_3_state));
      it.printf(5, 80, id(font_small), "Button presses: %d", id(button_press_count));
      
      if (id(shift_register_detected)) {
        it.print(5, 95, id(font_small), "SHIFT REGISTER FOUND!");
        it.printf(5, 110, id(font_small), "Active buttons detected");
      } else {
        it.print(5, 95, id(font_small), "Testing shift registers...");
        it.print(5, 110, id(font_small), "Press buttons during test");
      }

globals:
  - id: shift_reg_1_state
    type: uint8_t
    restore_value: false
    initial_value: '0x00'
  - id: shift_reg_2_state
    type: uint8_t
    restore_value: false
    initial_value: '0x00'
  - id: shift_reg_3_state
    type: uint8_t
    restore_value: false
    initial_value: '0x00'
  - id: button_press_count
    type: int
    restore_value: false
    initial_value: '0'
  - id: shift_register_detected
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: last_sr1_state
    type: uint8_t
    restore_value: false
    initial_value: '0xFF'
  - id: last_sr2_state
    type: uint8_t
    restore_value: false
    initial_value: '0xFF'
  - id: last_sr3_state
    type: uint8_t
    restore_value: false
    initial_value: '0xFF'

# Custom sensor to read shift registers manually
sensor:
  - platform: template
    name: "Shift Register Scanner"
    id: shift_register_scanner
    update_interval: 200ms
    lambda: |-
      // Manual SPI communication for shift registers
      // Try different CS pins that might be connected to shift registers
      
      std::vector<int> cs_pins = {10, 11, 12, 13, 14, 37, 39, 40, 41, 42};
      
      for (int cs_pin : cs_pins) {
        // Configure CS pin
        pinMode(cs_pin, OUTPUT);
        digitalWrite(cs_pin, HIGH);
        delayMicroseconds(10);
        
        // Start SPI transaction
        digitalWrite(cs_pin, LOW);
        delayMicroseconds(10);
        
        // Read 8 bits from potential shift register
        uint8_t received = 0;
        for (int bit = 7; bit >= 0; bit--) {
          digitalWrite(7, HIGH);  // Clock high (GPIO7)
          delayMicroseconds(5);
          if (digitalRead(9)) {   // Read MISO (GPIO9)
            received |= (1 << bit);
          }
          digitalWrite(7, LOW);   // Clock low
          delayMicroseconds(5);
        }
        
        digitalWrite(cs_pin, HIGH);
        
        // Check for button pattern changes
        if (cs_pin == GPIO10 && received != id(last_sr1_state)) {
          id(shift_reg_1_state) = received;
          id(last_sr1_state) = received;
          if (received != 0xFF && received != 0x00) {
            id(shift_register_detected) = true;
            id(button_press_count)++;
            ESP_LOGE("SHIFT_REG", "âœ… SR1 (CS:%d) Button pattern: 0x%02X", cs_pin, received);
          }
        } else if (cs_pin == GPIO11 && received != id(last_sr2_state)) {
          id(shift_reg_2_state) = received;
          id(last_sr2_state) = received;
          if (received != 0xFF && received != 0x00) {
            id(shift_register_detected) = true;
            id(button_press_count)++;
            ESP_LOGE("SHIFT_REG", "âœ… SR2 (CS:%d) Button pattern: 0x%02X", cs_pin, received);
          }
        } else if (cs_pin == GPIO12 && received != id(last_sr3_state)) {
          id(shift_reg_3_state) = received;
          id(last_sr3_state) = received;
          if (received != 0xFF && received != 0x00) {
            id(shift_register_detected) = true;
            id(button_press_count)++;
            ESP_LOGE("SHIFT_REG", "âœ… SR3 (CS:%d) Button pattern: 0x%02X", cs_pin, received);
          }
        }
        
        // Small delay between CS pin tests
        delayMicroseconds(50);
      }
      
      return id(button_press_count);
    on_value:
      - component.update: my_display

binary_sensor:
  # Test GPIO5 reference
  - platform: gpio
    pin:
      number: GPIO5
      mode: INPUT_PULLUP
      inverted: true
    name: "Reference_GPIO5"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - logger.log: "ðŸŸ¢ REFERENCE: GPIO5 works"

script:
  # Test button matrix scanning (alternative approach)
  - id: test_button_matrix
    then:
      - lambda: |-
          // Test 2x2 button matrix scanning
          // Row pins: GPIO15, GPIO16 (outputs)
          // Col pins: GPIO17, GPIO18 (inputs with pullups)
          
          std::vector<int> row_pins = {15, 16};
          std::vector<int> col_pins = {17, 18};
          
          // Configure pins
          for (int row : row_pins) {
            pinMode(row, OUTPUT);
            digitalWrite(row, HIGH);  // Inactive
          }
          for (int col : col_pins) {
            pinMode(col, INPUT_PULLUP);
          }
          
          // Scan matrix
          for (int r = 0; r < 2; r++) {
            // Activate row
            digitalWrite(row_pins[r], LOW);
            delayMicroseconds(100);
            
            // Read columns
            for (int c = 0; c < 2; c++) {
              if (!digitalRead(col_pins[c])) {
                ESP_LOGE("MATRIX", "âœ… MATRIX BUTTON: Row %d, Col %d", r, c);
                id(button_press_count)++;
                id(shift_register_detected) = true;  // Reuse flag
              }
            }
            
            // Deactivate row
            digitalWrite(row_pins[r], HIGH);
            delayMicroseconds(50);
          }

interval:
  - interval: 1s
    then:
      - script.execute: test_button_matrix
      - logger.log: "ðŸ” SPI Shift Register Test - Press buttons during scan"
      - component.update: my_display